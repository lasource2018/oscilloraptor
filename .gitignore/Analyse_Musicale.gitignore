import math
import wave, struct
from struct import *
from time import sleep
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from music21 import *

def lecture_Son(nomFichier) :
    
    data = []
    f = wave.open(nomFichier, 'rb')

    nbreCanaux = f.getnchannels()
    nbreEchant = f.getnframes()
    tailleEchant = f.getsampwidth()
    fech = f.getframerate()
    """
    print("Nombre de canaux :", nbreCanaux)
    print("Féquence d'échantillonnage :", fech)
    print("Taille de chaque échantillon :", tailleEchant, "octets")
    print("Nombre d'échantillons :", nbreEchant)

    print("Lecture du fichier...")
    """
    if tailleEchant == 2 :
        for i in range(nbreEchant) :
            b = f.readframes(1)
            val = struct.unpack('h', b)
            data.append(val[0])
    elif tailleEchant == 1 :
        for i in range(nbreEchant) :
            b = f.readframes(1)
            val = struct.unpack('b', b)
            data.append(val[0])
    else :
        print("Format de fichier non reconnu")
        
    
    return data,nbCanaux,nbreEchant,fech


def Ecriture_Son(nomFichier, listeEch) :

    fech = 44100    #par défault pour le moment, mais peut être choisit par l'utilisateur
    nbreOctets = 2
    nbreCanaux = 1
    
    nbreEchant = len(listeEch)
    parametres = (nbreCanaux, nbreOctets,fech, nbreEchant, 'NONE', 'notcompressed')
    
    print("Enregistrement du fichier...")
    
    Liste = []
    for i in range(nbreEchant) :
        b = struct.pack('h',listeEch[i])
        Liste.append(b[0])
        Liste.append(b[1])
    
    data = bytes(Liste)
    
    f = wave.open(nomFichier, 'wb')
    f.setparams(parametres)
    f.writeframes(data)
    f.close()


oc = { "Do": 131, "Do#": 139, "Re": 147, "Re#": 156, "Mi": 165, "Fa": 175, "Fa#": 185, "Sol": 196, "Sol#": 208, "La": 220, "Sib" :233, "Si" : 247 }

oc2 = { "Do": 262, "Do#": 277, "Re": 294, "Re#": 311, "Mi": 330, "Fa": 349, "Fa#": 370, "Sol": 392, "Sol#": 415, "La": 440, "Sib" :466, "Si" : 494, "Do2" : 523 }

DoM = [oc["Do"],oc["Re"],oc["Mi"],oc["Fa"],oc["Sol"],oc["La"],oc["Si"],oc2["Do"] ] 

#Gammes avec #
SolM = [oc["Sol"],oc["La"],oc["Si"],oc2["Do"],oc2["Re"],oc2["Mi"],oc2["Fa#"],oc2["Sol"]]
ReM = [oc["Re"],oc["Mi"],oc["Fa#"],oc["Sol"],oc["La"],oc["Si"],oc2["Do#"],oc2["Re"]]
LaM = [oc["La"],oc["Si"],oc2["Do#"],oc2["Re"],oc2["Mi"],oc2["Fa#"],oc2["Sol#"],oc2["La"]] 
MiM = [oc["Mi"],oc["Fa#"],oc["Sol#"],oc["La"],oc["Si"],oc2["Do#"],oc2["Re#"],oc2["Mi"]] 
SiM = [oc["Si"],oc2["Do#"],oc2["Re#"],oc2["Mi"],oc2["Fa#"],oc2["Sol#"],oc2["Sib"],oc2["Si"]] 
Fa_M = [oc["Fa#"],oc["Sol#"],oc["Sib"],oc["Si"],oc2["Do#"],oc2["Re#"],oc2["Fa"],oc2["Fa#"]] 
Do_M = [oc["Do#"],oc["Re#"],oc["Fa"],oc["Fa#"],oc["Sol#"],oc["Sib"],oc["Do"],oc2["Do#"]]

#Gammes avec bémol
# A faire


def ecrire_gamme(nom_fichier,gamme,amplitude,tps_note):
    E = []
    n = gamme
    for i in range(len(n)):
        O = [int(round(amplitude*math.sin(2*math.pi*n[i]*t*(1/44100)))) for t in  range(44100*tps_note)]
        E.extend(O)
    Ecriture_Son(nom_fichier, E)
    
ecrire_gamme("gamme_SolM.wav",SolM,5000,1)


def func(x,a,b,c):
    return c * np.exp( -np.power( (x-a)/b, 2) )
 
plt.ion()   # utilise pyplot en interactif
 
# Ouverture du fichier wav a decrypter
f,x, nbCanaux, nbFrames, fech = lecture_Son("gamme.wav")

#Decouper le fichier pour analyser chaque note après l'autre 
frequences, freq_gauss, FreqNoteJuste, ListeNote = [], [], []
larg_frame = 44100
for posi in range(0,nbFrames,larg_frame):
 
    # Sequence contenant une note
    f.setpos(posi)
    donnee = f.readframes(larg_frame)
    data = struct.unpack('%sh' % (larg_frame*nbCanaux ), donnee)

    # Transformee de Fourier
    w     = np.fft.fft(data)
    sig   = np.real(w * w.conjugate())
    freqs = np.fft.fftfreq(len(w)) * nbFrames
 
    # Estimation de la frequence
    idx = np.argmax(sig)
    f0, maxi = np.abs(freqs[idx]), sig[idx]
    frequences.append( f0 )
    
    #Ajustement par une gaussienne
    ind = np.where( np.abs(freqs - f0) < 20 )
    popt, pcov = curve_fit( func, freqs[ind], sig[ind]/maxi, p0=[f0,1,1] )
    a, b, c = popt
    freq_gauss.append(a)
    FreqNoteJuste.append(notefreqJuste(a, False, False))
    

f.close()
  
for res in (frequences,freq_gauss):
    print(np.round(res, 0))
#Analyse des Fréquences fournit soit par le générateur ou l'analyseur 
"""    
A = [261.63, 293.66, 329.63, 349.23, 392.00,440.00, 493.88]
#F
B = [349.23, 392.00, 440.00, 493.88,523.25, 587.33,659.26]
#A aéolien
L = [3520.00, 3951.07,4186.01,4698.64,5274.04, 5587.65,6271.93]
Diese = 1
"""

ListeNoteMusic21 = []
TailleListePrincipale = len(L)


#création des listes de notes 
def Octave(freq, sortin):
    n = 0
    # pour reconnaitre les notes, on les transpose à l'octave 3. Cela permet une meilleur optimisation
    while freq < 255 or a > 500 :
        if freq < 255:
            freq = freq * 2
            n = n - 1
        elif freq > 500:
            freq = freq/2
            n = n + n
    if sortin:
        return n
    else:
        return freq
def notefreqjuste (frequence, SortieLettre, Diese):
    a = octave(frequence,False)
    n = octave(frequence,True) + 3
    if a < 263 and a > 259:
        if SortieLettre:
            return "C"
        else: 
            return 261.63 * 2 **(n-3)
    elif a < 279 and a > 275 :
        if sortieLettre:
            if Diese:
                return "C#"
            else:
                return "Db"
        else:
            return 277.18 * 2 ** (n-3)
    elif a < 295 and a > 290:
        if SortieLettre:
            return "D"
        else :
            return 293.66 * 2 **(n-3)
    elif a < 313 and a > 309:
        if SortieLettre:
            if Diese:
                return "D#"
            else:
                return "Eb"
        else:
            return 311.13 * 2 ** (n-3)
    elif a < 332 and a > 326:
        if SortieLettre:
            return "E"
        else :
            return 329.63 * 2 **(n-3)
    elif a < 351 and a > 346:
        if SortieLettre:
            return "F"
        else:
            return 349.23 * 2 ** (n-3)
    elif a < 371 and a > 366:
        if SortieLettre:
            if Diese:
                return "F#"
            else :
                return "Gb"
        else:
            return 369.99 * 2 ** (n-3)
    elif a < 395 and a > 389:
        if SortiLettre:
            return "G"
        else:
            return 392.00 * 2 ** (n-3)
    elif a < 418 and a > 412:
        if SortieLettre:
            if Diese:
                return "G#"
            else:
                return "Ab"
        else
            return  415.30 * 2 ** (n-3)
    elif a < 443 and a > 437:
        if SortieLettre:
           return "A"
        else:
            return 440.00 * 2 ** (n-3)
    elif a < 469 and a > 463:
        if SortieLettre:
            if Diese:
                return "A#"
            else:
                return "Bb"
        else :
            return 466.16 * 2 **(n-3)
    elif a < 496 and 490:
        if SortieLettre:
            return "B"
        else:
            return 493.88 * 2 ** (n-3)

#fonction pour reconnaitre un intervalle, ou pour donner la position dans la liste
def ton(L, pos):
    TailleListe = len(L)
    for loop in range(TailleListe):
        #calcule du rapport des frequence entre la note tonales et les autre notes
        quotient = L[Loop]/L[0]
        #rapport s'approche de 
        if quotien < 1.16 and > 1.10
            if pos:
                return loop
                break
            else: 
                return True
                break
def tiercemaj(L, pos):
    TailleListe = len(L)
    for loop in range(TailleListe):
        quotien = L[loop]/L[0]
        if quotien <1.26 and quotien > 1.24:
            if pos == 1:
                return loop
                break
            else :
                return True
                break
def tiercemin(L, pos):
    TailleListe = len(L)
    for loop in range(TailleListe):
        quotien = L[loop]/L[0]
        if quotien < 1.23 and quotient > 1.18
            if pos == 1:
                return loop
                break
            else :
                return True
                break
def quartejuste(L,pos):
    TailleListe = len(L)
    for loop in range(TailleListe):
        quotien = L[loop]/L[0]
        if quotien < 1.34 and quotien > 1.32:
            if pos == 1:
                return loop
            else :
                return True
                break
        
def quintejuste(L,pos):
    TailleListe = len(L)
    for loop in range(TailleListe):
        quotien = L[loop]/L[0]
        if quotien >1.49  and quotien < 1.51:
            if pos == 1:
                return loop
                break
            else:
                return True
                break
    
def sixtemaj(L,pos, CalcVTheorique):
    TailleListe = len(L)
    if CalcVTheorique:
        Valeursixte = L[0] * (5/4) *(4/3)
    else:
        Valeursixte = L[quartejuste(L,True)] * (5/3)
    for loop in range(TailleListe):
        quotien = L[loop]/Valeursixte
        if 0.9 < quotien <= 1:
            if pos == 1:
                return loop
                break
            else:
                return True
                break

def septiememaj(L,pos,CalcVTheorique):
    TailleListe = len(L)
    if CalcVTheorique:
        Valeurseptieme = L[0] * (3/2) * (5/4)
    else:
        Valeurseptieme = L[quintejuste(L,True)]*(5/4)
    for loop in range(TailleListe):
        quotien = L[loop]/Valeurseptieme
        if 0.9 < quotien < 1:
            if pos ==1:
                return loop
                break
            else:
                return True
                break
def septiememin(L,pos,CalcVTheorique):
    TailleListe = len(L)
    if CalcVTheorique:
        Valeurseptieme = L[0] * (3/2) * (3/2)
    else:
        Valeurseptieme = L[quintejuste(L,True)]*(3/2)
    for loop in range(TailleListe):
        quotien = L[loop]/Valeurseptieme
        if 0.9 < quotien < 1:
            if pos ==1:
                return loop
                break
            else:
                return True
                break
def neuviememaj(L, pos, CalcVThéorique):
    TailleListe = len(L)
    if CalcVThéorique:
        valeurneuvieme = (L[0] * (3/2)*(4/3))/2
    else :
        positionquinte = quintejuste(L,True)
        valeurneuvieme = L[positionquinte] * (3/2))/2
    for loop in range(TailleListe):
        quotien = L[loop]/valeurneuvieme
        if quotien > 0.9 and quotien <1 :
            if pos == 1 : 
                return loop
                break
            else:
                return True
                break

def GammeDeffinisseur(Liste):
    if tiercemaj(Liste, False):
        if quartejuste(Liste, False):
            if septiememaj(Liste, False, False):
                return "Ionien"
            else:
                return "Mixolydien"
        else :
            return "Lydien"
    else :
        if quintejuste(Liste, False):
            if sixtemaj(Liste, False, False):
                if ton(Liste, False):
                    return "Aéolien"
                else:
                    return "Phrygien"
            else:
                return "Dorien"
        else:
            return "Locrien"

#Détections d'accords            
def AccordDeffinisseurTaille3(Liste):
    if TailleListePrincipale == 3 :
        if tiercemaj(Liste, False):
            if quintejuste(Liste, False):
               return " "
            elif sixtemaje(Liste, False,True):
                return "6"
            else:
                return "Unknown Chord"
        elif tiercemin(Liste, False):
            if quintejuste(Liste, False):
                return "m"
            elif
                return "m6"
            else:
                return "Unknown Chord"
        elif quartejuste(Liste, False):
            if quintejuste(Liste, False):
                return "sus4"
            else :
                return "Unknown Chord"
        elif neuviememaj(Liste, False):
            if quintejuste(Liste, False):
                return "sus2"
        elif octave(Liste, False):
            if quintejuste(Liste, False):
                return "PowerChord HEEEELL YEAH"
            elif:
                return "Unknown Chord"
        else:
            return "Unknown Chord"
def accordsept(Liste):
    if septiememin(Liste, False):
        if AccordDeffinisseurTaille3(Liste, False) == "6" or "m6" or "sus4" or "sus2":
            return"/7"
        else:
            return"7"
    if septiememaj(Liste):
        if AccordDeffinisseurTaille3(Liste) == "6" or "m6" or "sus4" or "sus2":
            return "/∆"
        else :
            return "∆"
    
#détection d'intervalles            
def IntervalleDeffinisseur(Liste):
    if ton(Liste, False):
        return "Seconde Majeur"
    if tiercemaj(Liste,False):
        return "Tierce Majeur"   
    elif quartejuste(Liste,False):
        return "Quarte Juste"
    elif quintejuste(Liste,False):
        return "Quinte Juste"              
    elif sixtemaj(Liste,False,True):
        return "Sixte Majeur"
    elif septiememaj(Liste, False, True):
        return "septième Majeur

def TrieurParTaille(Liste):
    Taille = len(Liste)
    if Taille == 1:
        return Liste[0]
    elif Taille == 2:
        return IntervalleDeffinisseur(Liste)
    elif Taille == 3
        return AccordDeffinisseurTaille3(Liste)
    elif Taille < 5:
        return GammeDeffinisseur(Liste)
"""       
affichage gamme
besoin des liste ListeNote et ListeOctaveNote
pour les transformer en liste music21
"""
def Streamcreation(ListeNote,ListeOctaveNote):
    stream1 = stream.Stream()
    for loop in range(TailleListePrincipale):
        Note1 = note.Note("C4")
        Note1.name = ListeNote[loop]
        Note1.octave = ListeOctaveNote[loop]
        stream1.append(Note1)
    return stream1
